{"columns": ["role: system", "role: user", "role: assistant"], "data": [["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object that is ready to be parsed.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\",\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\",\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\",\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n    ", "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using defaultgripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear1 is inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\",\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using defaultgripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\",\n                },\n                {\n                    \"summary\": \"Check the precondition that defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\",\n                },\n                {\n                    \"summary\": \"Insert gear1 into shaft1 using defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\",\n                }\n            ]\n        }\n    ]\n}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\",\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\",\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\",\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n    ", "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using defaultgripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear1 is inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\",\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using defaultgripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\",\n                },\n                {\n                    \"summary\": \"Check the precondition that defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\",\n                },\n                {\n                    \"summary\": \"Insert gear1 into shaft1 using defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\",\n                }\n            ]\n        }\n    ]\n}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\",\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\",\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\",\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    ", "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using defaultgripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear1 is inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\",\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using defaultgripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\",\n                },\n                {\n                    \"summary\": \"Check the precondition that defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\",\n                },\n                {\n                    \"summary\": \"Insert gear1 into shaft1 using defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\",\n                }\n            ]\n        }\n    ]\n}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    ", "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using defaultgripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear1 is inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using defaultgripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"Insert gear1 into shaft1 using defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    ", "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 is holding shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    ", "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 is holding shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    ", "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 is holding shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    ", "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: unload_tool(left_hand, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    ", "{\n    \"summary\": \"Selector to unload the outward_claw in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding a outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"Unload the outward_claw in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    ", "{\n    \"summary\": \"Selector to pick up the shaft1 with the parallel_box1 in the left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the parallel_box1 is holding the shaft1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up the shaft1 with the parallel_box1 in the left hand\",\n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding the parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Pick up the shaft1 with the parallel_box1 in the left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"]]}