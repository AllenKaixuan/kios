{"columns": ["role: system", "role: user", "role: assistant"], "data": [["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(shaft1, gearbase_hole1)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': []}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}], 'relations': [{'source': 'outwardgripper', 'name': 'hold', 'target': 'gear2'}, {'source': 'left_hand', 'name': 'hold', 'target': 'outwardgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the shaft1 into the gearbase_hole1 with the clampgripper in the left_hand', 'name': 'selector: insert(left_hand, clampgripper, shaft1, gearbase_hole1)', 'children': [{'summary': 'the target is to make the shaft1 be inserted into the gearbase_hole1', 'name': 'target: is_inserted_to(shaft1, gearbase_hole1)'}, {'summary': 'sequence to insert the shaft1 into the gearbase_hole1 with the clampgripper in the left_hand', 'name': 'sequence: insert(left_hand, clampgripper, shaft1, gearbase_hole1)', 'children': [{'summary': 'selector to change tool in left_hand from outwardgripper to clampgripper', 'name': 'selector: change_tool(left_hand, outwardgripper, clampgripper)', 'children': [{'summary': 'the target is to make left_hand hold clampgripper', 'name': 'target: hold(left_hand, clampgripper)'}, {'summary': 'sequence to change tool in left_hand from outwardgripper to clampgripper', 'name': 'sequence: change_tool(left_hand, outwardgripper, clampgripper)', 'children': [{'summary': 'a precondition is left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'selector to put down the gear2 held by the outwardgripper in the left_hand', 'name': 'selector: put_down(left_hand, outwardgripper, gear2)', 'children': [{'summary': 'the target is to make the outwardgripper empty', 'name': 'target: is_empty(outwardgripper)'}, {'summary': 'sequence to put down the gear2 held by the outwardgripper in the left_hand', 'name': 'sequence: put_down(left_hand, outwardgripper, gear2)', 'children': [{'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'a precondition is the outwardgripper is holding gear2', 'name': 'precondition: hold(outwardgripper, gear2)'}, {'summary': 'the action to put down the gear2 held by the outwardgripper in the left_hand', 'name': 'action: put_down(left_hand, outwardgripper, gear2)'}]}]}, {'summary': 'the action to change tool in left_hand from outwardgripper to clampgripper', 'name': 'action: change_tool(left_hand, outwardgripper, clampgripper)'}]}]}, {'summary': 'selector to pick up the shaft1 with the clampgripper in the left_hand', 'name': 'selector: pick_up(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'the target is to make the clampgripper hold the shaft1', 'name': 'target: hold(clampgripper, shaft1)'}, {'summary': 'sequence to pick up the shaft1 with the clampgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'a precondition is the clampgripper is empty', 'name': 'precondition: is_empty(clampgripper)'}, {'summary': 'a precondition is the left_hand is holding clampgripper', 'name': 'precondition: hold(left_hand, clampgripper)'}, {'summary': 'the action to pick up the shaft1 with the clampgripper in the left_hand', 'name': 'action: pick_up(left_hand, clampgripper, shaft1)'}]}]}, {'summary': 'the action to insert the shaft1 into the gearbase_hole1 with the clampgripper in the left_hand', 'name': 'action: insert(left_hand, clampgripper, shaft1, gearbase_hole1)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(shaft1, gearbase_hole1)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'outwardgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the shaft1 into the gearbase_hole1 with the clampgripper in the left_hand', 'name': 'selector: insert(left_hand, clampgripper, shaft1, gearbase_hole1)', 'children': [{'summary': 'the target is to make the shaft1 be inserted into the gearbase_hole1', 'name': 'target: is_inserted_to(shaft1, gearbase_hole1)'}, {'summary': 'sequence to insert the shaft1 into the gearbase_hole1 with the clampgripper in the left_hand', 'name': 'sequence: insert(left_hand, clampgripper, shaft1, gearbase_hole1)', 'children': [{'summary': 'selector to change tool in left_hand from outwardgripper to clampgripper', 'name': 'selector: change_tool(left_hand, outwardgripper, clampgripper)', 'children': [{'summary': 'the target is to make left_hand hold clampgripper', 'name': 'target: hold(left_hand, clampgripper)'}, {'summary': 'sequence to change tool in left_hand from outwardgripper to clampgripper', 'name': 'sequence: change_tool(left_hand, outwardgripper, clampgripper)', 'children': [{'summary': 'a precondition is left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'a precondition is outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'the action to change tool in left_hand from outwardgripper to clampgripper', 'name': 'action: change_tool(left_hand, outwardgripper, clampgripper)'}]}]}, {'summary': 'selector to pick up the shaft1 with the clampgripper in the left_hand', 'name': 'selector: pick_up(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'the target is to make the clampgripper hold the shaft1', 'name': 'target: hold(clampgripper, shaft1)'}, {'summary': 'sequence to pick up the shaft1 with the clampgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'a precondition is the clampgripper is empty', 'name': 'precondition: is_empty(clampgripper)'}, {'summary': 'a precondition is the left_hand is holding clampgripper', 'name': 'precondition: hold(left_hand, clampgripper)'}, {'summary': 'the action to pick up the shaft1 with the clampgripper in the left_hand', 'name': 'action: pick_up(left_hand, clampgripper, shaft1)'}]}]}, {'summary': 'the action to insert the shaft1 into the gearbase_hole1 with the clampgripper in the left_hand', 'name': 'action: insert(left_hand, clampgripper, shaft1, gearbase_hole1)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear2, shaft2)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'outwardgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the gear2 into the shaft2 with the outwardgripper in the left_hand', 'name': 'selector: insert(left_hand, outwardgripper, gear2, shaft2)', 'children': [{'summary': 'the target is to make the gear2 be inserted into the shaft2', 'name': 'target: is_inserted_to(gear2, shaft2)'}, {'summary': 'sequence to insert the gear2 into the shaft2 with the outwardgripper in the left_hand', 'name': 'sequence: insert(left_hand, outwardgripper, gear2, shaft2)', 'children': [{'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'selector to pick up the gear2 with the outwardgripper in the left_hand', 'name': 'selector: pick_up(left_hand, outwardgripper, gear2)', 'children': [{'summary': 'the target is to make the outwardgripper hold the gear2', 'name': 'target: hold(outwardgripper, gear2)'}, {'summary': 'sequence to pick up the gear2 with the outwardgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, outwardgripper, gear2)', 'children': [{'summary': 'a precondition is the outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'the action to pick up the gear2 with the outwardgripper in the left_hand', 'name': 'action: pick_up(left_hand, outwardgripper, gear2)'}]}]}, {'summary': 'the action to insert the gear2 into the shaft2 with the outwardgripper in the left_hand', 'name': 'action: insert(left_hand, outwardgripper, gear2, shaft2)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear2, shaft2)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': []}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}], 'relations': [{'source': 'clampgripper', 'name': 'hold', 'target': 'shaft1'}, {'source': 'left_hand', 'name': 'hold', 'target': 'clampgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the gear2 into the shaft2 with the outwardgripper in the left_hand', 'name': 'selector: insert(left_hand, outwardgripper, gear2, shaft2)', 'children': [{'summary': 'the target is to make the gear2 be inserted into the shaft2', 'name': 'target: is_inserted_to(gear2, shaft2)'}, {'summary': 'sequence to insert the gear2 into the shaft2 with the outwardgripper in the left_hand', 'name': 'sequence: insert(left_hand, outwardgripper, gear2, shaft2)', 'children': [{'summary': 'selector to change tool in left_hand from clampgripper to outwardgripper', 'name': 'selector: change_tool(left_hand, clampgripper, outwardgripper)', 'children': [{'summary': 'the target is to make left_hand hold outwardgripper', 'name': 'target: hold(left_hand, outwardgripper)'}, {'summary': 'sequence to change tool in left_hand from clampgripper to outwardgripper', 'name': 'sequence: change_tool(left_hand, clampgripper, outwardgripper)', 'children': [{'summary': 'a precondition is left_hand is holding clampgripper', 'name': 'precondition: hold(left_hand, clampgripper)'}, {'summary': 'selector to put down the shaft1 held by the clampgripper in the left_hand', 'name': 'selector: put_down(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'the target is to make the clampgripper empty', 'name': 'target: is_empty(clampgripper)'}, {'summary': 'sequence to put down the shaft1 held by the clampgripper in the left_hand', 'name': 'sequence: put_down(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'a precondition is the left_hand is holding clampgripper', 'name': 'precondition: hold(left_hand, clampgripper)'}, {'summary': 'a precondition is the clampgripper is holding shaft1', 'name': 'precondition: hold(clampgripper, shaft1)'}, {'summary': 'the action to put down the shaft1 held by the clampgripper in the left_hand', 'name': 'action: put_down(left_hand, clampgripper, shaft1)'}]}]}, {'summary': 'the action to change tool in left_hand from clampgripper to outwardgripper', 'name': 'action: change_tool(left_hand, clampgripper, outwardgripper)'}]}]}, {'summary': 'selector to pick up the gear2 with the outwardgripper in the left_hand', 'name': 'selector: pick_up(left_hand, outwardgripper, gear2)', 'children': [{'summary': 'the target is to make the outwardgripper hold the gear2', 'name': 'target: hold(outwardgripper, gear2)'}, {'summary': 'sequence to pick up the gear2 with the outwardgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, outwardgripper, gear2)', 'children': [{'summary': 'a precondition is the outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'the action to pick up the gear2 with the outwardgripper in the left_hand', 'name': 'action: pick_up(left_hand, outwardgripper, gear2)'}]}]}, {'summary': 'the action to insert the gear2 into the shaft2 with the outwardgripper in the left_hand', 'name': 'action: insert(left_hand, outwardgripper, gear2, shaft2)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear3, shaft3)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': []}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'clampgripper'}, {'source': 'clampgripper', 'name': 'hold', 'target': 'shaft1'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'selector: insert(left_hand, outwardgripper, gear3, shaft3)', 'children': [{'summary': 'the target is to make the gear3 be inserted into the shaft3', 'name': 'target: is_inserted_to(gear3, shaft3)'}, {'summary': 'sequence to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'sequence: insert(left_hand, outwardgripper, gear3, shaft3)', 'children': [{'summary': 'selector to change tool in left_hand from clampgripper to outwardgripper', 'name': 'selector: change_tool(left_hand, clampgripper, outwardgripper)', 'children': [{'summary': 'the target is to make left_hand hold outwardgripper', 'name': 'target: hold(left_hand, outwardgripper)'}, {'summary': 'sequence to change tool in left_hand from clampgripper to outwardgripper', 'name': 'sequence: change_tool(left_hand, clampgripper, outwardgripper)', 'children': [{'summary': 'a precondition is left_hand is holding clampgripper', 'name': 'precondition: hold(left_hand, clampgripper)'}, {'summary': 'selector to put down the shaft1 held by the clampgripper in the left_hand', 'name': 'selector: put_down(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'the target is to make the clampgripper empty', 'name': 'target: is_empty(clampgripper)'}, {'summary': 'sequence to put down the shaft1 held by the clampgripper in the left_hand', 'name': 'sequence: put_down(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'a precondition is the left_hand is holding clampgripper', 'name': 'precondition: hold(left_hand, clampgripper)'}, {'summary': 'a precondition is the clampgripper is holding shaft1', 'name': 'precondition: hold(clampgripper, shaft1)'}, {'summary': 'the action to put down the shaft1 held by the clampgripper in the left_hand', 'name': 'action: put_down(left_hand, clampgripper, shaft1)'}]}]}, {'summary': 'the action to change tool in left_hand from clampgripper to outwardgripper', 'name': 'action: change_tool(left_hand, clampgripper, outwardgripper)'}]}]}, {'summary': 'selector to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'selector: pick_up(left_hand, outwardgripper, gear3)', 'children': [{'summary': 'the target is to make the outwardgripper hold the gear3', 'name': 'target: hold(outwardgripper, gear3)'}, {'summary': 'sequence to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, outwardgripper, gear3)', 'children': [{'summary': 'a precondition is the outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'the action to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'action: pick_up(left_hand, outwardgripper, gear3)'}]}]}, {'summary': 'the action to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'action: insert(left_hand, outwardgripper, gear3, shaft3)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear3, shaft3)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'defaultgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'selector: insert(left_hand, outwardgripper, gear3, shaft3)', 'children': [{'summary': 'the target is to make the gear3 be inserted into the shaft3', 'name': 'target: is_inserted_to(gear3, shaft3)'}, {'summary': 'sequence to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'sequence: insert(left_hand, outwardgripper, gear3, shaft3)', 'children': [{'summary': 'selector to change tool in left_hand from clampgripper to outwardgripper', 'name': 'selector: change_tool(left_hand, clampgripper, outwardgripper)', 'children': [{'summary': 'the target is to make left_hand hold outwardgripper', 'name': 'target: hold(left_hand, outwardgripper)'}, {'summary': 'sequence to change tool in left_hand from clampgripper to outwardgripper', 'name': 'sequence: change_tool(left_hand, clampgripper, outwardgripper)', 'children': [{'summary': 'selector to change tool in left_hand from defaultgripper to clampgripper', 'name': 'selector: change_tool(left_hand, defaultgripper, clampgripper)', 'children': [{'summary': 'the target is to make left_hand hold clampgripper', 'name': 'target: hold(left_hand, clampgripper)'}, {'summary': 'sequence to change tool in left_hand from defaultgripper to clampgripper', 'name': 'sequence: change_tool(left_hand, defaultgripper, clampgripper)', 'children': [{'summary': 'a precondition is left_hand is holding defaultgripper', 'name': 'precondition: hold(left_hand, defaultgripper)'}, {'summary': 'a precondition is defaultgripper is empty', 'name': 'precondition: is_empty(defaultgripper)'}, {'summary': 'the action to change tool in left_hand from defaultgripper to clampgripper', 'name': 'action: change_tool(left_hand, defaultgripper, clampgripper)'}]}]}, {'summary': 'a precondition is clampgripper is empty', 'name': 'precondition: is_empty(clampgripper)'}, {'summary': 'the action to change tool in left_hand from clampgripper to outwardgripper', 'name': 'action: change_tool(left_hand, clampgripper, outwardgripper)'}]}]}, {'summary': 'selector to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'selector: pick_up(left_hand, outwardgripper, gear3)', 'children': [{'summary': 'the target is to make the outwardgripper hold the gear3', 'name': 'target: hold(outwardgripper, gear3)'}, {'summary': 'sequence to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, outwardgripper, gear3)', 'children': [{'summary': 'a precondition is the outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'the action to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'action: pick_up(left_hand, outwardgripper, gear3)'}]}]}, {'summary': 'the action to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'action: insert(left_hand, outwardgripper, gear3, shaft3)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear3, shaft3)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'outwardgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'selector: insert(left_hand, outwardgripper, gear3, shaft3)', 'children': [{'summary': 'the target is to make the gear3 be inserted into the shaft3', 'name': 'target: is_inserted_to(gear3, shaft3)'}, {'summary': 'sequence to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'sequence: insert(left_hand, outwardgripper, gear3, shaft3)', 'children': [{'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'selector to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'selector: pick_up(left_hand, outwardgripper, gear3)', 'children': [{'summary': 'the target is to make the outwardgripper hold the gear3', 'name': 'target: hold(outwardgripper, gear3)'}, {'summary': 'sequence to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, outwardgripper, gear3)', 'children': [{'summary': 'a precondition is the outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'the action to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'action: pick_up(left_hand, outwardgripper, gear3)'}]}]}, {'summary': 'the action to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'action: insert(left_hand, outwardgripper, gear3, shaft3)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear1, shaft1)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}], 'relations': [{'source': 'shaft1', 'name': 'is_inserted_to', 'target': 'gearbase_hole1'}, {'source': 'left_hand', 'name': 'hold', 'target': 'outwardgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the gear1 into the shaft1 with the parallelgripper in the left_hand', 'name': 'selector: insert(left_hand, parallelgripper, gear1, shaft1)', 'children': [{'summary': 'the target is to make the gear1 be inserted into the shaft1', 'name': 'target: is_inserted_to(gear1, shaft1)'}, {'summary': 'sequence to insert the gear1 into the shaft1 with the parallelgripper in the left_hand', 'name': 'sequence: insert(left_hand, parallelgripper, gear1, shaft1)', 'children': [{'summary': 'selector to change tool in left_hand from outwardgripper to parallelgripper', 'name': 'selector: change_tool(left_hand, outwardgripper, parallelgripper)', 'children': [{'summary': 'the target is to make left_hand hold parallelgripper', 'name': 'target: hold(left_hand, parallelgripper)'}, {'summary': 'sequence to change tool in left_hand from outwardgripper to parallelgripper', 'name': 'sequence: change_tool(left_hand, outwardgripper, parallelgripper)', 'children': [{'summary': 'a precondition is left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'a precondition is outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'the action to change tool in left_hand from outwardgripper to parallelgripper', 'name': 'action: change_tool(left_hand, outwardgripper, parallelgripper)'}]}]}, {'summary': 'selector to pick up the gear1 with the parallelgripper in the left_hand', 'name': 'selector: pick_up(left_hand, parallelgripper, gear1)', 'children': [{'summary': 'the target is to make the parallelgripper hold the gear1', 'name': 'target: hold(parallelgripper, gear1)'}, {'summary': 'sequence to pick up the gear1 with the parallelgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, parallelgripper, gear1)', 'children': [{'summary': 'a precondition is the parallelgripper is empty', 'name': 'precondition: is_empty(parallelgripper)'}, {'summary': 'a precondition is the left_hand is holding parallelgripper', 'name': 'precondition: hold(left_hand, parallelgripper)'}, {'summary': 'the action to pick up the gear1 with the parallelgripper in the left_hand', 'name': 'action: pick_up(left_hand, parallelgripper, gear1)'}]}]}, {'summary': 'the action to insert the gear1 into the shaft1 with the parallelgripper in the left_hand', 'name': 'action: insert(left_hand, parallelgripper, gear1, shaft1)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear1, shaft1)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}], 'relations': [{'source': 'shaft1', 'name': 'is_inserted_to', 'target': 'gearbase_hole1'}, {'source': 'left_hand', 'name': 'hold', 'target': 'outwardgripper'}, {'source': 'gear1', 'name': 'is_inserted_to', 'target': 'shaft1'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'the target is to insert gear1 to shaft1', 'name': 'target: is_inserted_to(gear1, shaft1)'}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear3, shaft3)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}], 'relations': [{'source': 'gear1', 'name': 'is_inserted_to', 'target': 'shaft1'}, {'source': 'shaft1', 'name': 'is_inserted_to', 'target': 'gearbase_hole1'}, {'source': 'shaft3', 'name': 'is_inserted_to', 'target': 'gearbase_hole3'}, {'source': 'left_hand', 'name': 'hold', 'target': 'defaultgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'selector: insert(left_hand, outwardgripper, gear3, shaft3)', 'children': [{'summary': 'the target is to make the gear3 be inserted into the shaft3', 'name': 'target: is_inserted_to(gear3, shaft3)'}, {'summary': 'sequence to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'sequence: insert(left_hand, outwardgripper, gear3, shaft3)', 'children': [{'summary': 'selector to change tool in left_hand from defaultgripper to outwardgripper', 'name': 'selector: change_tool(left_hand, defaultgripper, outwardgripper)', 'children': [{'summary': 'the target is to make left_hand hold outwardgripper', 'name': 'target: hold(left_hand, outwardgripper)'}, {'summary': 'sequence to change tool in left_hand from defaultgripper to outwardgripper', 'name': 'sequence: change_tool(left_hand, defaultgripper, outwardgripper)', 'children': [{'summary': 'a precondition is left_hand is holding defaultgripper', 'name': 'precondition: hold(left_hand, defaultgripper)'}, {'summary': 'a precondition is defaultgripper is empty', 'name': 'precondition: is_empty(defaultgripper)'}, {'summary': 'the action to change tool in left_hand from defaultgripper to outwardgripper', 'name': 'action: change_tool(left_hand, defaultgripper, outwardgripper)'}]}]}, {'summary': 'selector to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'selector: pick_up(left_hand, outwardgripper, gear3)', 'children': [{'summary': 'the target is to make the outwardgripper hold the gear3', 'name': 'target: hold(outwardgripper, gear3)'}, {'summary': 'sequence to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, outwardgripper, gear3)', 'children': [{'summary': 'a precondition is the outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'the action to pick up the gear3 with the outwardgripper in the left_hand', 'name': 'action: pick_up(left_hand, outwardgripper, gear3)'}]}]}, {'summary': 'the action to insert the gear3 into the shaft3 with the outwardgripper in the left_hand', 'name': 'action: insert(left_hand, outwardgripper, gear3, shaft3)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(shaft1, gearbase_hole1)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': []}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'defaultgripper'}, {'source': 'defaultgripper', 'name': 'hold', 'target': 'shaft3'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the shaft1 into the gearbase_hole1 with the clampgripper in the left_hand', 'name': 'selector: insert(left_hand, clampgripper, shaft1, gearbase_hole1)', 'children': [{'summary': 'the target is to make the shaft1 be inserted into the gearbase_hole1', 'name': 'target: is_inserted_to(shaft1, gearbase_hole1)'}, {'summary': 'sequence to insert the shaft1 into the gearbase_hole1 with the clampgripper in the left_hand', 'name': 'sequence: insert(left_hand, clampgripper, shaft1, gearbase_hole1)', 'children': [{'summary': 'selector to change tool in left_hand from defaultgripper to clampgripper', 'name': 'selector: change_tool(left_hand, defaultgripper, clampgripper)', 'children': [{'summary': 'the target is to make left_hand hold clampgripper', 'name': 'target: hold(left_hand, clampgripper)'}, {'summary': 'sequence to change tool in left_hand from defaultgripper to clampgripper', 'name': 'sequence: change_tool(left_hand, defaultgripper, clampgripper)', 'children': [{'summary': 'a precondition is left_hand is holding defaultgripper', 'name': 'precondition: hold(left_hand, defaultgripper)'}, {'summary': 'selector to put down the shaft3 held by the defaultgripper in the left_hand', 'name': 'selector: put_down(left_hand, defaultgripper, shaft3)', 'children': [{'summary': 'the target is to make the defaultgripper empty', 'name': 'target: is_empty(defaultgripper)'}, {'summary': 'sequence to put down the shaft3 held by the defaultgripper in the left_hand', 'name': 'sequence: put_down(left_hand, defaultgripper, shaft3)', 'children': [{'summary': 'a precondition is the left_hand is holding defaultgripper', 'name': 'precondition: hold(left_hand, defaultgripper)'}, {'summary': 'a precondition is the defaultgripper is holding shaft3', 'name': 'precondition: hold(defaultgripper, shaft3)'}, {'summary': 'the action to put down the shaft3 held by the defaultgripper in the left_hand', 'name': 'action: put_down(left_hand, defaultgripper, shaft3)'}]}]}, {'summary': 'the action to change tool in left_hand from defaultgripper to clampgripper', 'name': 'action: change_tool(left_hand, defaultgripper, clampgripper)'}]}]}, {'summary': 'selector to pick up the shaft1 with the clampgripper in the left_hand', 'name': 'selector: pick_up(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'the target is to make the clampgripper hold the shaft1', 'name': 'target: hold(clampgripper, shaft1)'}, {'summary': 'sequence to pick up the shaft1 with the clampgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, clampgripper, shaft1)', 'children': [{'summary': 'a precondition is the clampgripper is empty', 'name': 'precondition: is_empty(clampgripper)'}, {'summary': 'a precondition is the left_hand is holding clampgripper', 'name': 'precondition: hold(left_hand, clampgripper)'}, {'summary': 'the action to pick up the shaft1 with the clampgripper in the left_hand', 'name': 'action: pick_up(left_hand, clampgripper, shaft1)'}]}]}, {'summary': 'the action to insert the shaft1 into the gearbase_hole1 with the clampgripper in the left_hand', 'name': 'action: insert(left_hand, clampgripper, shaft1, gearbase_hole1)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear2, shaft2)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'defaultgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the gear2 into the shaft2 with the outwardgripper in the left_hand', 'name': 'selector: insert(left_hand, outwardgripper, gear2, shaft2)', 'children': [{'summary': 'the target is to make the gear2 be inserted into the shaft2', 'name': 'target: is_inserted_to(gear2, shaft2)'}, {'summary': 'sequence to insert the gear2 into the shaft2 with the outwardgripper in the left_hand', 'name': 'sequence: insert(left_hand, outwardgripper, gear2, shaft2)', 'children': [{'summary': 'selector to change tool in left_hand from defaultgripper to outwardgripper', 'name': 'selector: change_tool(left_hand, defaultgripper, outwardgripper)', 'children': [{'summary': 'the target is to make left_hand hold outwardgripper', 'name': 'target: hold(left_hand, outwardgripper)'}, {'summary': 'sequence to change tool in left_hand from defaultgripper to outwardgripper', 'name': 'sequence: change_tool(left_hand, defaultgripper, outwardgripper)', 'children': [{'summary': 'a precondition is left_hand is holding defaultgripper', 'name': 'precondition: hold(left_hand, defaultgripper)'}, {'summary': 'a precondition is defaultgripper is empty', 'name': 'precondition: is_empty(defaultgripper)'}, {'summary': 'the action to change tool in left_hand from defaultgripper to outwardgripper', 'name': 'action: change_tool(left_hand, defaultgripper, outwardgripper)'}]}]}, {'summary': 'selector to pick up the gear2 with the outwardgripper in the left_hand', 'name': 'selector: pick_up(left_hand, outwardgripper, gear2)', 'children': [{'summary': 'the target is to make the outwardgripper hold the gear2', 'name': 'target: hold(outwardgripper, gear2)'}, {'summary': 'sequence to pick up the gear2 with the outwardgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, outwardgripper, gear2)', 'children': [{'summary': 'a precondition is the outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'the action to pick up the gear2 with the outwardgripper in the left_hand', 'name': 'action: pick_up(left_hand, outwardgripper, gear2)'}]}]}, {'summary': 'the action to insert the gear2 into the shaft2 with the outwardgripper in the left_hand', 'name': 'action: insert(left_hand, outwardgripper, gear2, shaft2)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(shaft3, gearbase_hole3)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'inwardgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the shaft3 into the gearbase_hole3 with the defaultgripper in the left_hand', 'name': 'selector: insert(left_hand, defaultgripper, shaft3, gearbase_hole3)', 'children': [{'summary': 'the target is to make the shaft3 be inserted into the gearbase_hole3', 'name': 'target: is_inserted_to(shaft3, gearbase_hole3)'}, {'summary': 'sequence to insert the shaft3 into the gearbase_hole3 with the defaultgripper in the left_hand', 'name': 'sequence: insert(left_hand, defaultgripper, shaft3, gearbase_hole3)', 'children': [{'summary': 'selector to change tool in left_hand from inwardgripper to defaultgripper', 'name': 'selector: change_tool(left_hand, inwardgripper, defaultgripper)', 'children': [{'summary': 'the target is to make left_hand hold defaultgripper', 'name': 'target: hold(left_hand, defaultgripper)'}, {'summary': 'sequence to change tool in left_hand from inwardgripper to defaultgripper', 'name': 'sequence: change_tool(left_hand, inwardgripper, defaultgripper)', 'children': [{'summary': 'a precondition is left_hand is holding inwardgripper', 'name': 'precondition: hold(left_hand, inwardgripper)'}, {'summary': 'a precondition is inwardgripper is empty', 'name': 'precondition: is_empty(inwardgripper)'}, {'summary': 'the action to change tool in left_hand from inwardgripper to defaultgripper', 'name': 'action: change_tool(left_hand, inwardgripper, defaultgripper)'}]}]}, {'summary': 'selector to pick up the shaft3 with the defaultgripper in the left_hand', 'name': 'selector: pick_up(left_hand, defaultgripper, shaft3)', 'children': [{'summary': 'the target is to make the defaultgripper hold the shaft3', 'name': 'target: hold(defaultgripper, shaft3)'}, {'summary': 'sequence to pick up the shaft3 with the defaultgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, defaultgripper, shaft3)', 'children': [{'summary': 'a precondition is the defaultgripper is empty', 'name': 'precondition: is_empty(defaultgripper)'}, {'summary': 'a precondition is the left_hand is holding defaultgripper', 'name': 'precondition: hold(left_hand, defaultgripper)'}, {'summary': 'the action to pick up the shaft3 with the defaultgripper in the left_hand', 'name': 'action: pick_up(left_hand, defaultgripper, shaft3)'}]}]}, {'summary': 'the action to insert the shaft3 into the gearbase_hole3 with the defaultgripper in the left_hand', 'name': 'action: insert(left_hand, defaultgripper, shaft3, gearbase_hole3)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(shaft3, gearbase_hole3)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': []}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'parallelgripper'}, {'source': 'parallelgripper', 'name': 'hold', 'target': 'gear1'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the shaft3 into the gearbase_hole3 with the defaultgripper in the left_hand', 'name': 'selector: insert(left_hand, defaultgripper, shaft3, gearbase_hole3)', 'children': [{'summary': 'the target is to make the shaft3 be inserted into the gearbase_hole3', 'name': 'target: is_inserted_to(shaft3, gearbase_hole3)'}, {'summary': 'sequence to insert the shaft3 into the gearbase_hole3 with the defaultgripper in the left_hand', 'name': 'sequence: insert(left_hand, defaultgripper, shaft3, gearbase_hole3)', 'children': [{'summary': 'selector to change tool in left_hand from parallelgripper to defaultgripper', 'name': 'selector: change_tool(left_hand, parallelgripper, defaultgripper)', 'children': [{'summary': 'the target is to make left_hand hold defaultgripper', 'name': 'target: hold(left_hand, defaultgripper)'}, {'summary': 'sequence to change tool in left_hand from parallelgripper to defaultgripper', 'name': 'sequence: change_tool(left_hand, parallelgripper, defaultgripper)', 'children': [{'summary': 'a precondition is left_hand is holding parallelgripper', 'name': 'precondition: hold(left_hand, parallelgripper)'}, {'summary': 'selector to put down the gear1 held by the parallelgripper in the left_hand', 'name': 'selector: put_down(left_hand, parallelgripper, gear1)', 'children': [{'summary': 'the target is to make the parallelgripper empty', 'name': 'target: is_empty(parallelgripper)'}, {'summary': 'sequence to put down the gear1 held by the parallelgripper in the left_hand', 'name': 'sequence: put_down(left_hand, parallelgripper, gear1)', 'children': [{'summary': 'a precondition is the left_hand is holding parallelgripper', 'name': 'precondition: hold(left_hand, parallelgripper)'}, {'summary': 'a precondition is the parallelgripper is holding gear1', 'name': 'precondition: hold(parallelgripper, gear1)'}, {'summary': 'the action to put down the gear1 held by the parallelgripper in the left_hand', 'name': 'action: put_down(left_hand, parallelgripper, gear1)'}]}]}, {'summary': 'the action to change tool in left_hand from parallelgripper to defaultgripper', 'name': 'action: change_tool(left_hand, parallelgripper, defaultgripper)'}]}]}, {'summary': 'selector to pick up the shaft3 with the defaultgripper in the left_hand', 'name': 'selector: pick_up(left_hand, defaultgripper, shaft3)', 'children': [{'summary': 'the target is to make the defaultgripper hold the shaft3', 'name': 'target: hold(defaultgripper, shaft3)'}, {'summary': 'sequence to pick up the shaft3 with the defaultgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, defaultgripper, shaft3)', 'children': [{'summary': 'a precondition is the defaultgripper is empty', 'name': 'precondition: is_empty(defaultgripper)'}, {'summary': 'a precondition is the left_hand is holding defaultgripper', 'name': 'precondition: hold(left_hand, defaultgripper)'}, {'summary': 'the action to pick up the shaft3 with the defaultgripper in the left_hand', 'name': 'action: pick_up(left_hand, defaultgripper, shaft3)'}]}]}, {'summary': 'the action to insert the shaft3 into the gearbase_hole3 with the defaultgripper in the left_hand', 'name': 'action: insert(left_hand, defaultgripper, shaft3, gearbase_hole3)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear2, shaft2)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': []}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'lampbase', 'properties': []}, {'name': 'chair_leg1', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}], 'relations': [{'source': 'gear2', 'name': 'is_inserted_to', 'target': 'shaft2'}, {'source': 'parallelgripper', 'name': 'hold', 'target': 'gear1'}, {'source': 'left_hand', 'name': 'hold', 'target': 'parallelgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'the target is to insert the gear2 into the shaft2', 'name': 'target: is_inserted_to(gear2, shaft2)'}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear3, shaft3)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': []}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'lampbase', 'properties': []}, {'name': 'chair_leg1', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}], 'relations': [{'source': 'shaft1', 'name': 'is_inserted_to', 'target': 'gearbase_hole1'}, {'source': 'left_hand', 'name': 'hold', 'target': 'parallelgripper'}, {'source': 'gear3', 'name': 'is_inserted_to', 'target': 'shaft3'}, {'source': 'shaft3', 'name': 'is_inserted_to', 'target': 'gearbase_hole3'}, {'source': 'gear2', 'name': 'is_inserted_to', 'target': 'shaft2'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'the target is to insert gear3 into shaft3', 'name': 'target: is_inserted_to(gear3, shaft3)'}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(gear1, shaft1)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'gear1', 'properties': []}, {'name': 'gear2', 'properties': []}, {'name': 'gear3', 'properties': []}, {'name': 'shaft1', 'properties': []}, {'name': 'shaft2', 'properties': []}, {'name': 'shaft3', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'lampbase', 'properties': []}, {'name': 'chair_leg1', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'gear2', 'name': 'can_insert_to', 'target': 'shaft2'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear3'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'gear2'}, {'source': 'gear3', 'name': 'can_insert_to', 'target': 'shaft3'}, {'source': 'shaft3', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'shaft1', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'gear1'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'shaft1'}, {'source': 'gear1', 'name': 'can_insert_to', 'target': 'shaft1'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'shaft3'}], 'relations': [{'source': 'shaft3', 'name': 'is_inserted_to', 'target': 'gearbase_hole3'}, {'source': 'shaft1', 'name': 'is_inserted_to', 'target': 'gearbase_hole1'}, {'source': 'left_hand', 'name': 'hold', 'target': 'inwardgripper'}, {'source': 'gear2', 'name': 'is_inserted_to', 'target': 'shaft2'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the gear1 into the shaft1 with the parallelgripper in the left_hand', 'name': 'selector: insert(left_hand, parallelgripper, gear1, shaft1)', 'children': [{'summary': 'the target is to make the gear1 be inserted into the shaft1', 'name': 'target: is_inserted_to(gear1, shaft1)'}, {'summary': 'sequence to insert the gear1 into the shaft1 with the parallelgripper in the left_hand', 'name': 'sequence: insert(left_hand, parallelgripper, gear1, shaft1)', 'children': [{'summary': 'selector to change tool in left_hand from inwardgripper to parallelgripper', 'name': 'selector: change_tool(left_hand, inwardgripper, parallelgripper)', 'children': [{'summary': 'the target is to make left_hand hold parallelgripper', 'name': 'target: hold(left_hand, parallelgripper)'}, {'summary': 'sequence to change tool in left_hand from inwardgripper to parallelgripper', 'name': 'sequence: change_tool(left_hand, inwardgripper, parallelgripper)', 'children': [{'summary': 'a precondition is left_hand is holding inwardgripper', 'name': 'precondition: hold(left_hand, inwardgripper)'}, {'summary': 'a precondition is inwardgripper is empty', 'name': 'precondition: is_empty(inwardgripper)'}, {'summary': 'the action to change tool in left_hand from inwardgripper to parallelgripper', 'name': 'action: change_tool(left_hand, inwardgripper, parallelgripper)'}]}]}, {'summary': 'selector to pick up the gear1 with the parallelgripper in the left_hand', 'name': 'selector: pick_up(left_hand, parallelgripper, gear1)', 'children': [{'summary': 'the target is to make the parallelgripper hold the gear1', 'name': 'target: hold(parallelgripper, gear1)'}, {'summary': 'sequence to pick up the gear1 with the parallelgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, parallelgripper, gear1)', 'children': [{'summary': 'a precondition is the parallelgripper is empty', 'name': 'precondition: is_empty(parallelgripper)'}, {'summary': 'a precondition is the left_hand is holding parallelgripper', 'name': 'precondition: hold(left_hand, parallelgripper)'}, {'summary': 'the action to pick up the gear1 with the parallelgripper in the left_hand', 'name': 'action: pick_up(left_hand, parallelgripper, gear1)'}]}]}, {'summary': 'the action to insert the gear1 into the shaft1 with the parallelgripper in the left_hand', 'name': 'action: insert(left_hand, parallelgripper, gear1, shaft1)'}]}]}"], ["You are an excellent behavior tree builder for robotic assembly tasks", "Human: You are an excellent interpreter of instructions for robotic assembly tasks.\n\n    The input are:\ntarget: The target that you make the sequential plan and construct the behavior tree to achieve.\ninitial_state: The initial state that you start from.\n\nYou analyze the target, refer to the domain knowledge to understand it, make an action sequence and construct a behavior tree based on it.\nYour output should be a json object which follows the regulated format.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The target is to make the tool <tool> empty. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    Information about world states should be in json dictionary format.\nIt contains three lists: \n    - objects: the objects and their properties (as lists of strings) in the world. The properties can be changed by robot actions.\n    - constraints: the constraint relations that are enforced and should not be changed. They are knowledge about the world or some constraints set by the user.\n    - relations: the relations in the world. They can be changed by robot actions.\nThe properties, constraints and relations should always align with the [PREDICATE_LIST] in the domain knowledge.\n\n    The behavior tree should be in json dictionary format.\nFollowing is a simple example:\n\"\"\"\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"the target is that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"The action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\"\"\"\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions.\n4. All the node should always have their corresponding actions/precidates in the domain knowledge.\n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\n\n7. If any precondition node will be unsatisfied when it is ticked, a unit subtree should be constructed to replace it, which take that precondition node as its target node and aims to achieve it. You should estimate the world state when the precondition is ticked (checked) according to the initial state and the effects of the actions executed before, then do this replacement repeatedly until all the preconditions are satisfied at the time they are ticked.  \n8. The behavior tree should be constructed based on the action sequence you planned and the action definitions in ROBOT_ACTION_LIST.\n9. Control flow nodes (sequence nodes and selector nodes) don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n\n    The output json obejct has the following keys:\n\"\"\"\n- \"thought\": A brief explanation of the thinking process behind the action sequence.\n- \"action_sequence\": A sequential list of robot actions. Only the actions defined in the \"ROBOT_ACTION LIST\" will be used.\n- \"behavior_tree\": A json dictionary form behavior tree constructed according to the \"action_sequence\"\n\"\"\"\n\n    Resume from the input below.\n\"\"\"\ntarget: target: is_inserted_to(compoundgear, cylindershaft)\ninitial_state: {'objects': [{'name': 'clampgripper', 'properties': ['is_empty']}, {'name': 'parallelgripper', 'properties': ['is_empty']}, {'name': 'inwardgripper', 'properties': ['is_empty']}, {'name': 'outwardgripper', 'properties': ['is_empty']}, {'name': 'defaultgripper', 'properties': ['is_empty']}, {'name': 'smallgear', 'properties': []}, {'name': 'compoundgear', 'properties': []}, {'name': 'largegear', 'properties': []}, {'name': 'smallshaft', 'properties': []}, {'name': 'cylindershaft', 'properties': []}, {'name': 'largeshaft', 'properties': []}, {'name': 'gearbase', 'properties': []}, {'name': 'gearbase_hole1', 'properties': []}, {'name': 'gearbase_hole3', 'properties': []}, {'name': 'left_hand', 'properties': []}], 'constraints': [{'source': 'smallshaft', 'name': 'can_insert_to', 'target': 'gearbase_hole1'}, {'source': 'clampgripper', 'name': 'can_manipulate', 'target': 'smallshaft'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'largegear'}, {'source': 'largegear', 'name': 'can_insert_to', 'target': 'largeshaft'}, {'source': 'defaultgripper', 'name': 'can_manipulate', 'target': 'largeshaft'}, {'source': 'compoundgear', 'name': 'can_insert_to', 'target': 'cylindershaft'}, {'source': 'largeshaft', 'name': 'can_insert_to', 'target': 'gearbase_hole3'}, {'source': 'smallgear', 'name': 'can_insert_to', 'target': 'smallshaft'}, {'source': 'outwardgripper', 'name': 'can_manipulate', 'target': 'compoundgear'}, {'source': 'parallelgripper', 'name': 'can_manipulate', 'target': 'smallgear'}], 'relations': [{'source': 'left_hand', 'name': 'hold', 'target': 'outwardgripper'}]}\n\"\"\" \n\n    Return a JSON object.\n    ", "{'summary': 'selector to insert the compoundgear into the cylindershaft with the outwardgripper in the left_hand', 'name': 'selector: insert(left_hand, outwardgripper, compoundgear, cylindershaft)', 'children': [{'summary': 'the target is to make the compoundgear be inserted into the cylindershaft', 'name': 'target: is_inserted_to(compoundgear, cylindershaft)'}, {'summary': 'sequence to insert the compoundgear into the cylindershaft with the outwardgripper in the left_hand', 'name': 'sequence: insert(left_hand, outwardgripper, compoundgear, cylindershaft)', 'children': [{'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'selector to pick up the compoundgear with the outwardgripper in the left_hand', 'name': 'selector: pick_up(left_hand, outwardgripper, compoundgear)', 'children': [{'summary': 'the target is to make the outwardgripper hold the compoundgear', 'name': 'target: hold(outwardgripper, compoundgear)'}, {'summary': 'sequence to pick up the compoundgear with the outwardgripper in the left_hand', 'name': 'sequence: pick_up(left_hand, outwardgripper, compoundgear)', 'children': [{'summary': 'a precondition is the outwardgripper is empty', 'name': 'precondition: is_empty(outwardgripper)'}, {'summary': 'a precondition is the left_hand is holding outwardgripper', 'name': 'precondition: hold(left_hand, outwardgripper)'}, {'summary': 'the action to pick up the compoundgear with the outwardgripper in the left_hand', 'name': 'action: pick_up(left_hand, outwardgripper, compoundgear)'}]}]}, {'summary': 'the action to insert the compoundgear into the cylindershaft with the outwardgripper in the left_hand', 'name': 'action: insert(left_hand, outwardgripper, compoundgear, cylindershaft)'}]}]}"]]}