{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object that is ready to be parsed.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\",\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\",\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\",\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using defaultgripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear1 is inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\",\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using defaultgripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\",\n                },\n                {\n                    \"summary\": \"Check the precondition that defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\",\n                },\n                {\n                    \"summary\": \"Insert gear1 into shaft1 using defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\",\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\",\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\",\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\",\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using defaultgripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear1 is inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\",\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using defaultgripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\",\n                },\n                {\n                    \"summary\": \"Check the precondition that defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\",\n                },\n                {\n                    \"summary\": \"Insert gear1 into shaft1 using defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\",\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\",\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\",\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\",\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using defaultgripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear1 is inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\",\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using defaultgripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\",\n                },\n                {\n                    \"summary\": \"Check the precondition that defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\",\n                },\n                {\n                    \"summary\": \"Insert gear1 into shaft1 using defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\",\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using defaultgripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear1 is inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using defaultgripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"Insert gear1 into shaft1 using defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 is holding shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 is holding shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 is holding shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: unload_tool(left_hand, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to unload the outward_claw in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding a outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"Unload the outward_claw in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up the shaft1 with the parallel_box1 in the left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the parallel_box1 is holding the shaft1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up the shaft1 with the parallel_box1 in the left hand\",\n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding the parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Pick up the shaft1 with the parallel_box1 in the left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that parallel_box1 is holding shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that shaft1 can be inserted into gearbase_hole1\",\n                    \"name\": \"precondition: can_insert_to(shaft1, gearbase_hole1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: unload_tool(left_hand, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to unload the outward_claw in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding an outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"Unload the outward_claw in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that parallel_box1 is holding shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that shaft1 can be inserted into gearbase_hole1\",\n                    \"name\": \"precondition: can_insert_to(shaft1, gearbase_hole1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: unload_tool(left_hand, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to unload the outward_claw in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding an outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"Unload the outward_claw in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that parallel_box1 is holding shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that shaft1 can be inserted into gearbase_hole1\",\n                    \"name\": \"precondition: can_insert_to(shaft1, gearbase_hole1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: unload_tool(left_hand, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to unload the outward_claw in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding an outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"Unload the outward_claw in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up shaft1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that parallel_box1 is holding shaft1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up shaft1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that parallel_box1 is free\",\n                    \"name\": \"precondition: is_free(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that parallel_box1 can manipulate shaft1\",\n                    \"name\": \"precondition: can_manipulate(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Pick up shaft1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: put_down(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to put down the shaft1 in the left hand using parallel_box1\",\n    \"name\": \"selector: put_down(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the parallel_box1 is free\",\n            \"name\": \"target: is_free(parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to put down the shaft1 in the left hand using parallel_box1\",\n            \"name\": \"sequence: put_down(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is holding a shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Put down the shaft1 in the left hand using parallel_box1\",\n                    \"name\": \"action: put_down(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is holding a shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that shaft1 can be inserted into gearbase_hole1\",\n                    \"name\": \"precondition: can_insert_to(shaft1, gearbase_hole1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding a parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: unload_tool(left_hand, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to unload the outward_claw in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding an outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"Unload the outward_claw in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is inserted into gearbase_hole1\",\n            \"name\": \"target: is_inserted_to(shaft1, gearbase_hole1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is holding a shaft1\",\n                    \"name\": \"precondition: hold(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the shaft1 can be inserted into gearbase_hole1\",\n                    \"name\": \"precondition: can_insert_to(shaft1, gearbase_hole1)\"\n                },\n                {\n                    \"summary\": \"Insert shaft1 into gearbase_hole1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, shaft1, gearbase_hole1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: load_tool(left_hand, parallel_box1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to load the parallel_box1 in the left hand\",\n    \"name\": \"selector: load_tool(left_hand, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to load the tool in the left hand\",\n            \"name\": \"sequence: load_tool(left_hand, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is free\",\n                    \"name\": \"precondition: is_free(left_hand)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is equippable\",\n                    \"name\": \"precondition: is_equippable(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Load the parallel_box1 in the left hand\",\n                    \"name\": \"action: load_tool(left_hand, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: unload_tool(left_hand, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to unload the outward_claw in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding an outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"Unload the outward_claw in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_free ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_free ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_free ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_free ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_free ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_free ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_free ?hand))\n  :effect (and (not (is_free ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_free ?tool))\n  :effect (and (is_free ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_free(<tool> or <hand>): <tool> or <hand> is free and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be free to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be free to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be free.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be free.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is free\",\n            \"name\": \"target: is_free(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up shaft1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that parallel_box1 is holding shaft1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up shaft1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that parallel_box1 is free\",\n                    \"name\": \"precondition: is_free(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that parallel_box1 can manipulate shaft1\",\n                    \"name\": \"precondition: can_manipulate(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Pick up shaft1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_empty ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_empty ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_empty ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_empty ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_empty ?hand))\n  :effect (and (not (is_empty ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool))\n  :effect (and (is_empty ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool> or <hand>): <tool> or <hand> is empty and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be empty.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is empty\",\n            \"name\": \"target: is_empty(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up the shaft1 with parallel_box1 in the left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the parallel_box1 is holding shaft1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up the shaft1 with parallel_box1 in the left hand\",\n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is empty\",\n                    \"name\": \"precondition: is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 can manipulate shaft1\",\n                    \"name\": \"precondition: can_manipulate(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Pick up the shaft1 with parallel_box1 in the left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_empty ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_empty ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_empty ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_empty ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_empty ?hand))\n  :effect (and (not (is_empty ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool))\n  :effect (and (is_empty ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool> or <hand>): <tool> or <hand> is empty and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be empty.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is empty\",\n            \"name\": \"target: is_empty(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up shaft1 with parallel_box1 using left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that shaft1 is held by parallel_box1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up shaft1 with parallel_box1 using left hand\",\n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that left hand is holding parallel_box1 and parallel_box1 is empty\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1) and is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Pick up shaft1 with parallel_box1 using left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_empty ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_empty ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_empty ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_empty ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_empty ?hand))\n  :effect (and (not (is_empty ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool))\n  :effect (and (is_empty ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool> or <hand>): <tool> or <hand> is empty and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be empty.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is empty\",\n            \"name\": \"target: is_empty(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up shaft1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that parallel_box1 is holding shaft1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up shaft1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 is empty\",\n                    \"name\": \"precondition: is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 can manipulate shaft1\",\n                    \"name\": \"precondition: can_manipulate(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Pick up shaft1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_empty ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_empty ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_empty ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_empty ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_empty ?hand))\n  :effect (and (not (is_empty ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool))\n  :effect (and (is_empty ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool> or <hand>): <tool> or <hand> is empty and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be empty.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is empty\",\n            \"name\": \"target: is_empty(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up shaft1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that parallel_box1 is holding shaft1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up shaft1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 is empty\",\n                    \"name\": \"precondition: is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 can manipulate shaft1\",\n                    \"name\": \"precondition: can_manipulate(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Pick up shaft1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent task planner for robotic assembly tasks. Given the information about the world states and some instructions, you construct robot task plans represented by behaiovr trees. \n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need in pddl domain format, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\"\"\"\n(define (domain robot_assembly_problem-domain)\n (:requirements :strips :typing)\n (:types\n    thing - object\n    tool part hand - thing\n )\n (:predicates (is_empty ?p - thing) (is_equippable ?tool - tool) (can_manipulate ?tool - tool ?part - part) (can_insert_to ?part1 - part ?part2 - part) (can_screw_to ?part1 - part ?part2 - part) (can_place_to ?part1 - part ?part2 - part) (hold ?thing1 - thing ?thing2 - thing) (is_inserted_to ?part1 - part ?part2 - part) (is_screwed_to ?part1 - part ?part2 - part) (is_placed_to ?part1 - part ?part2 - part))\n (:action pick_up\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (is_empty ?tool) (hold ?hand ?tool) (can_manipulate ?tool ?part))\n  :effect (and (hold ?tool ?part) (not (is_empty ?tool))))\n (:action put_down\n  :parameters ( ?hand - hand ?tool - tool ?part - part)\n  :precondition (and (hold ?tool ?part) (hold ?hand ?tool))\n  :effect (and (not (hold ?hand ?part)) (is_empty ?tool)))\n (:action place\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_place_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_placed_to ?part1 ?part2)))\n (:action detach\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (can_manipulate ?tool ?part1) (is_placed_to ?part1 ?part2))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_placed_to ?part1 ?part2))))\n (:action insert\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_insert_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_inserted_to ?part1 ?part2)))\n (:action pull\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_inserted_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_inserted_to ?part1 ?part2))))\n (:action screw\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (hold ?tool ?part1) (can_screw_to ?part1 ?part2))\n  :effect (and (not (hold ?tool ?part1)) (is_empty ?tool) (is_screwed_to ?part1 ?part2)))\n (:action unscrew\n  :parameters ( ?hand - hand ?tool - tool ?part1 - part ?part2 - part)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool) (is_screwed_to ?part1 ?part2) (can_manipulate ?tool ?part1))\n  :effect (and (hold ?tool ?part1) (not (is_empty ?tool)) (not (is_screwed_to ?part1 ?part2))))\n (:action load_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (is_equippable ?tool) (is_empty ?hand))\n  :effect (and (not (is_empty ?hand)) (not (is_equippable ?tool)) (hold ?hand ?tool)))\n (:action unload_tool\n  :parameters ( ?hand - hand ?tool - tool)\n  :precondition (and (hold ?hand ?tool) (is_empty ?tool))\n  :effect (and (is_empty ?hand) (is_equippable ?tool) (not (hold ?hand ?tool))))\n)\n\"\"\"\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool> or <hand>): <tool> or <hand> is empty and can hold something. (default: true)\n- is_equippable(<tool>): <tool> is ready to be eqquipped by a robot hand. (default: true)\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint) (default: false)\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint) (default: false)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint) (default: false)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint) (default: false)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2> (default: false)\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied) (default: false)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied) (default: false)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied) (default: false)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty to hold something.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- load_tool(<hand>, <tool>): <hand> equips <tool> to manipulate other objects. As preconditions, <tool> should be equippable and <hand> should be empty.\n- unload_tool(<hand>, <tool>): <hand> unloads <tool> to manipulate other objects. As preconditions, <hand> should be holding <tool> and <tool> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: unload_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to unload the outwardgripper in the left hand\",\n    \"name\": \"selector: unload_tool(left_hand, outwardgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is empty\",\n            \"name\": \"target: is_empty(left_hand)\"\n        },\n        {\n            \"summary\": \"Sequence to unload the tool in the left hand\",\n            \"name\": \"sequence: unload_tool(left_hand, outwardgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding a outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Unload the outwardgripper in the left hand\",\n                    \"name\": \"action: unload_tool(left_hand, outwardgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up shaft1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that parallel_box1 is holding shaft1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up shaft1 using parallel_box1 in the left hand\",\n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that parallel_box1 is empty\",\n                    \"name\": \"precondition: is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that parallel_box1 can manipulate shaft1\",\n                    \"name\": \"precondition: can_manipulate(parallel_box1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Pick up shaft1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, parallel_box1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up shaft1 using parallel_box1 in the left hand\",\n    \"name\": \"selector: pick_up(left_hand, parallel_box1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that parallel_box1 is holding shaft1\",\n            \"name\": \"target: hold(parallel_box1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up shaft1 using parallel_box1 in the left hand\", \n            \"name\": \"sequence: pick_up(left_hand, parallel_box1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that parallel_box1 is empty\",\n                    \"name\": \"precondition: is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Action to pick up shaft1 using parallel_box1 in the left hand\",\n                    \"name\": \"action: pick_up(left_hand, parallel_box1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, outward_claw, gear2, shaft2)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear2 into shaft2 using the outward claw in the left hand\",\n    \"name\": \"selector: insert(left_hand, outward_claw, gear2, shaft2)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear2 is inserted into shaft2\",\n            \"name\": \"target: is_inserted_to(gear2, shaft2)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear2 into shaft2 using the outward claw in the left hand\", \n            \"name\": \"sequence: insert(left_hand, outward_claw, gear2, shaft2)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outward claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outward claw is holding gear2\",\n                    \"name\": \"precondition: hold(outward_claw, gear2)\"\n                },\n                {\n                    \"summary\": \"Action to insert gear2 into shaft2 using the outward claw in the left hand\",\n                    \"name\": \"action: insert(left_hand, outward_claw, gear2, shaft2)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: change_tool(left_hand, parallel_box1, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to change the tool in the left hand from parallel_box1 to outward_claw\",\n    \"name\": \"selector: change_tool(left_hand, parallel_box1, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the outward_claw\",\n            \"name\": \"target: hold(left_hand, outward_claw)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from parallel_box1 to outward_claw\", \n            \"name\": \"sequence: change_tool(left_hand, parallel_box1, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is empty\",\n                    \"name\": \"precondition: is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from parallel_box1 to outward_claw\",\n                    \"name\": \"action: change_tool(left_hand, parallel_box1, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, outward_claw, gear2)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up gear2 with outward_claw using left_hand\",\n    \"name\": \"selector: pick_up(left_hand, outward_claw, gear2)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the outward_claw is holding gear2\",\n            \"name\": \"target: hold(outward_claw, gear2)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up gear2 with outward_claw using left_hand\", \n            \"name\": \"sequence: pick_up(left_hand, outward_claw, gear2)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left_hand is holding the outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outward_claw is empty\",\n                    \"name\": \"precondition: is_empty(outward_claw)\"\n                },\n                {\n                    \"summary\": \"Action to pick up gear2 with outward_claw using left_hand\",\n                    \"name\": \"action: pick_up(left_hand, outward_claw, gear2)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, parallel_box1, gear2, shaft2)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear2 into shaft2 using parallel_box1 with left hand\",\n    \"name\": \"selector: insert(left_hand, parallel_box1, gear2, shaft2)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear2 is inserted into shaft2\",\n            \"name\": \"target: is_inserted_to(gear2, shaft2)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear2 into shaft2 using parallel_box1 with left hand\",\n            \"name\": \"sequence: insert(left_hand, parallel_box1, gear2, shaft2)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that left hand is holding parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that parallel_box1 is holding gear2\",\n                    \"name\": \"precondition: hold(parallel_box1, gear2)\"\n                },\n                {\n                    \"summary\": \"Action to insert gear2 into shaft2 using parallel_box1 with left hand\",\n                    \"name\": \"action: insert(left_hand, parallel_box1, gear2, shaft2)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, outward_claw, gear2, shaft2)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear2 into shaft2 using outward_claw in the left hand\",\n    \"name\": \"selector: insert(left_hand, outward_claw, gear2, shaft2)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear2 is inserted into shaft2\",\n            \"name\": \"target: is_inserted_to(gear2, shaft2)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear2 into shaft2 using outward_claw in the left hand\",\n            \"name\": \"sequence: insert(left_hand, outward_claw, gear2, shaft2)\",\n            \"children\": [\n                {\n                    \"summary\": \"Check the precondition that the left hand is holding outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"Check the precondition that outward_claw is holding gear2\",\n                    \"name\": \"precondition: hold(outward_claw, gear2)\"\n                },\n                {\n                    \"summary\": \"Action to insert gear2 into shaft2 using outward_claw in the left hand\",\n                    \"name\": \"action: insert(left_hand, outward_claw, gear2, shaft2)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: change_tool(left_hand, parallel_box1, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to change the tool in the left hand from outward_claw to parallel_box1\",\n    \"name\": \"selector: change_tool(left_hand, outward_claw, parallel_box1)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the parallel_box1\",\n            \"name\": \"target: hold(left_hand, parallel_box1)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outward_claw to parallel_box1\",\n            \"name\": \"sequence: change_tool(left_hand, outward_claw, parallel_box1)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outward_claw is empty\",\n                    \"name\": \"precondition: is_empty(outward_claw)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outward_claw to parallel_box1\",\n                    \"name\": \"action: change_tool(left_hand, outward_claw, parallel_box1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, outward_claw, gear2, shaft2)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear2 into shaft2 using the outward claw in the left hand\",\n    \"name\": \"selector: insert(left_hand, outward_claw, gear2, shaft2)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear2 is inserted into shaft2\",\n            \"name\": \"target: is_inserted_to(gear2, shaft2)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear2 into shaft2 using the outward claw in the left hand\", \n            \"name\": \"sequence: insert(left_hand, outward_claw, gear2, shaft2)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outward claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outward claw is holding gear2\",\n                    \"name\": \"precondition: hold(outward_claw, gear2)\"\n                },\n                {\n                    \"summary\": \"Action to insert gear2 into shaft2 using the outward claw in the left hand\",\n                    \"name\": \"action: insert(left_hand, outward_claw, gear2, shaft2)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: change_tool(left_hand, parallel_box1, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to change the tool in the left hand from parallel_box1 to outward_claw\",\n    \"name\": \"selector: change_tool(left_hand, parallel_box1, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the outward_claw\",\n            \"name\": \"target: hold(left_hand, outward_claw)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from parallel_box1 to outward_claw\", \n            \"name\": \"sequence: change_tool(left_hand, parallel_box1, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is empty\",\n                    \"name\": \"precondition: is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from parallel_box1 to outward_claw\",\n                    \"name\": \"action: change_tool(left_hand, parallel_box1, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, outward_claw, gear2)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up gear2 with outward_claw using left_hand\",\n    \"name\": \"selector: pick_up(left_hand, outward_claw, gear2)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the outward_claw is holding gear2\",\n            \"name\": \"target: hold(outward_claw, gear2)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up gear2 with outward_claw using left_hand\", \n            \"name\": \"sequence: pick_up(left_hand, outward_claw, gear2)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left_hand is holding the outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outward_claw is empty\",\n                    \"name\": \"precondition: is_empty(outward_claw)\"\n                },\n                {\n                    \"summary\": \"Action to pick up gear2 with outward_claw using left_hand\",\n                    \"name\": \"action: pick_up(left_hand, outward_claw, gear2)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: put_down(left_hand, outward_claw, gear2)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to put down gear2 using the outward claw in the left hand\",\n    \"name\": \"selector: put_down(left_hand, outward_claw, gear2)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the outward claw is not holding gear2\",\n            \"name\": \"target: not hold(outward_claw, gear2)\"\n        },\n        {\n            \"summary\": \"Sequence to put down gear2 using the outward claw in the left hand\", \n            \"name\": \"sequence: put_down(left_hand, outward_claw, gear2)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outward claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outward claw is holding gear2\",\n                    \"name\": \"precondition: hold(outward_claw, gear2)\"\n                },\n                {\n                    \"summary\": \"Action to put down gear2 using the outward claw in the left hand\",\n                    \"name\": \"action: put_down(left_hand, outward_claw, gear2)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, outward_claw, gear2, shaft2)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear2 into shaft2 using the outward claw in the left hand\",\n    \"name\": \"selector: insert(left_hand, outward_claw, gear2, shaft2)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that gear2 is inserted into shaft2\",\n            \"name\": \"target: is_inserted_to(gear2, shaft2)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear2 into shaft2 using the outward claw in the left hand\", \n            \"name\": \"sequence: insert(left_hand, outward_claw, gear2, shaft2)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outward claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outward claw is holding gear2\",\n                    \"name\": \"precondition: hold(outward_claw, gear2)\"\n                },\n                {\n                    \"summary\": \"Action to insert gear2 into shaft2 using the outward claw in the left hand\",\n                    \"name\": \"action: insert(left_hand, outward_claw, gear2, shaft2)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: change_tool(left_hand, parallel_box1, outward_claw)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to change the tool in the left hand from parallel_box1 to outward_claw\",\n    \"name\": \"selector: change_tool(left_hand, parallel_box1, outward_claw)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the outward_claw\",\n            \"name\": \"target: hold(left_hand, outward_claw)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from parallel_box1 to outward_claw\", \n            \"name\": \"sequence: change_tool(left_hand, parallel_box1, outward_claw)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the parallel_box1 is empty\",\n                    \"name\": \"precondition: is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from parallel_box1 to outward_claw\",\n                    \"name\": \"action: change_tool(left_hand, parallel_box1, outward_claw)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the left hand is holding the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: pick_up(left_hand, outward_claw, gear2)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to pick up gear2 with outward_claw using left_hand\",\n    \"name\": \"selector: pick_up(left_hand, outward_claw, gear2)\",\n    \"children\": [\n        {\n            \"summary\": \"Check the target that the outward_claw is holding gear2\",\n            \"name\": \"target: hold(outward_claw, gear2)\"\n        },\n        {\n            \"summary\": \"Sequence to pick up gear2 with outward_claw using left_hand\", \n            \"name\": \"sequence: pick_up(left_hand, outward_claw, gear2)\",\n            \"children\": [\n                {\n                    \"summary\": \"check the precondition that the left_hand is holding the outward_claw\",\n                    \"name\": \"precondition: hold(left_hand, outward_claw)\"\n                },\n                {\n                    \"summary\": \"check the precondition that the outward_claw is empty\",\n                    \"name\": \"precondition: is_empty(outward_claw)\"\n                },\n                {\n                    \"summary\": \"Action to pick up gear2 with outward_claw using left_hand\",\n                    \"name\": \"action: pick_up(left_hand, outward_claw, gear2)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"The target is to make the left hand hold the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Take the action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using left hand with defaultgripper\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"The target is to make gear1 inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using left hand with defaultgripper\", \n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"Take the action to insert gear1 into shaft1 using left hand with defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"The target is to make the left hand hold the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Take the action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using left hand with defaultgripper\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"The target is to make gear1 inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using left hand with defaultgripper\", \n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"Take the action to insert gear1 into shaft1 using left hand with defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"The target is to make the left hand hold the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Take the action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using left hand with defaultgripper\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"The target is to make gear1 inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using left hand with defaultgripper\", \n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the defaultgripper can manipulate gear1\",\n                    \"name\": \"precondition: can_manipulate(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"A precondition is that gear1 can be inserted into shaft1\",\n                    \"name\": \"precondition: can_insert_to(gear1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Take the action to insert gear1 into shaft1 using left hand with defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"The target is to make the left hand hold the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Take the action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using left hand with defaultgripper\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"The target is to make gear1 inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using left hand with defaultgripper\", \n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"A precondition is that gear1 can be inserted into shaft1\",\n                    \"name\": \"precondition: can_insert_to(gear1, shaft1)\"\n                },\n                {\n                    \"summary\": \"Take the action to insert gear1 into shaft1 using left hand with defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"The target is to make the left hand hold the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Take the action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using left hand with defaultgripper\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"The target is to make gear1 inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using left hand with defaultgripper\", \n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the defaultgripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the defaultgripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"Take the action to insert gear1 into shaft1 using left hand with defaultgripper\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"The target is to make the left hand hold the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Take the action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using the default gripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"The target is to have gear1 inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using the default gripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the default gripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the default gripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"Take the action to insert gear1 into shaft1 using the default gripper in the left hand\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"The target is to make the left hand hold the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Take the action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: insert(left_hand, defaultgripper, gear1, shaft1)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to insert gear1 into shaft1 using the default gripper in the left hand\",\n    \"name\": \"selector: insert(left_hand, defaultgripper, gear1, shaft1)\",\n    \"children\": [\n        {\n            \"summary\": \"The target is to have gear1 inserted into shaft1\",\n            \"name\": \"target: is_inserted_to(gear1, shaft1)\"\n        },\n        {\n            \"summary\": \"Sequence to insert gear1 into shaft1 using the default gripper in the left hand\",\n            \"name\": \"sequence: insert(left_hand, defaultgripper, gear1, shaft1)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the default gripper\",\n                    \"name\": \"precondition: hold(left_hand, defaultgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the default gripper is holding gear1\",\n                    \"name\": \"precondition: hold(defaultgripper, gear1)\"\n                },\n                {\n                    \"summary\": \"Take the action to insert gear1 into shaft1 using the default gripper in the left hand\",\n                    \"name\": \"action: insert(left_hand, defaultgripper, gear1, shaft1)\"\n                }\n            ]\n        }\n    ]\n}"}]}
{"messages": [{"role": "system", "content": "You are an excellent behavior tree builder for robotic assembly tasks"}, {"role": "user", "content": "You are an excellent behavior tree builder for robotic assembly tasks. Given an action, you construct a unit subtree for the action based on its definition in the domain knowledge.\n\n    The input are:\naction: The action that you construct the unit subtree from.\n\nYou analyze the action, refer to the domain knowledge to understand the action, and construct a unit subtree for it.\nThe unit subtree should follow the regulated format.\nYou only return the unit subtree as a json object.\n\n    Following is the domain knowledge you need, which includes:\n- the object types in the world,\n- the predicates for describing the states of the world,\n- the actions that the robot can apply, with their precondtions and effects defined.\n\nThe object types are explained as follows:\n\"\"\"\nthing: The base class for all objects in the world. Its subclasses are: hand, tool, part.\nhand: The robot hand. A empty <hand> can only hold one <tool> at a time.\ntool: The tool to manipulate <part>. A empty <tool> can hold one <part> at a time.\npart: The part to be manipulated.\n\"\"\"\n\nThe precidates are explained as follows:\n\"\"\"\n\"PREDICATE_LIST\"\n- is_empty(<tool>): <tool> is empty and can hold something.\n- can_manipulate(<tool>, <part>): <tool> can be used to manipulate <part> (manipulation constraint). This regulates the compatibility between <tool> and <part>.\n- can_insert_to(<part1>, <part2>): <part1> can be inserted into <part2> (insertion assembly constraint)\n- can_screw_to(<part1>, <part2>): <part1> can be screwed into <part2> (screw assembly constraint)\n- can_place_to(<part1>, <part2>): <part1> can be placed into <part2> (placement assembly constraint)\n- hold(<thing1>, <thing2>): <thing1> is holding <thing2>. It can be <hand> holding <tool> or <tool> holding <part>.\n- is_inserted_to(<part1>, <part2>): <part1> is inserted into <part2> (insertion assembly constraint is satisfied)\n- is_screwed_to(<part1>, <part2>): <part1> is screwed into <part2> (screw assembly constraint is satisfied)\n- is_placed_to(<part1>, <part2>): <part1> is placed into <part2> (placement assembly constraint is satisfied)\n\"\"\"\n\nThe actions are explained as follows:\n\"\"\"\n\"ROBOT_ACTION_LIST\"\n- pick_up(<hand>, <tool>, <part>): <hand> use <tool> to pick up <part>. As preconditions, <hand> should be holding <tool> and <tool> should be empty in order to hold the <part>. The <part> will be held by the <tool> as a result of this action.\n- put_down(<hand>, <tool>, <part>): <hand> use <tool> to put down <part>. As preconditions, <hand> should be holding <tool> and <tool> should be holding <part>. The <tool> will be empty and will not hold the <part> anymore as a result of this action.\n- place(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to place <part1> to <part2> (to satisfy the placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- detach(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to detach <part1> from <part2> (to lift the existing placement assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be placed into <part2>.\n- insert(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to insert <part1> into <part2> (to satisfy the insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- pull(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to pull <part1> from <part2> (to lift the existing insertion assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be inserted into <part2>.\n- screw(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to screw <part1> into <part2> (to satisfy the screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be holding <part1>.\n- unscrew(<hand>, <tool>, <part1>, <part2>): <hand> use <tool> to unscrew <part1> from <part2> (to lift the existing screw assembly constraint between <part1> and <part2>). As preconditions, <hand> should be holding <tool> and <tool> should be empty to manipulate <part1>, and <part1> should be screwed into <part2>.\n- change_tool(<hand>, <tool1>, <tool2>): <hand> change the equipped tool from <tool1> to <tool2> in order to manipulate specific parts. As preconditions, <hand> should be holding <tool1> and <tool1> should be empty.\n\"\"\"\nthe items in <> indicate the type of the instances needed for the predicates and actions.\n\n    The behavior tree should be in json dictionary format.\nWhen building a unit subtree, follow these rules:\n1. Every node are described by a summary and a name:\n    - \"summary\": a short interpretive description of the node. \n    - \"name\": includes the node type and the formal form of the node according to the domain knowledge. Legal node types are \"selector\", \"sequence\", \"condition\" (\"target\", \"precondition\"), \"action\".\n2. The control flow nodes, namely \"selector\" and \"sequence\", can have \"children\", which is a list of children nodes.\n3. The \"condition\" nodes that are children of \"selectors\" are targets. Those that are children of \"sequences\" are preconditions. \n4. All the node should always have their corresponding actions/precidates in the domain knowledge. \n5. Control flow nodes in behavior trees don't have memory. Each tick starts from the root and traverses all nodes, regardless of their previous state.\n6. The basic structure template of a unit subtree is:\n    - A selector as the root node. \n    - One target condition node as the first child of the selector to check if the target of this subtree has been satisfied.\n    - A sequence node as the last child of the selector node to achieve the target condition node.\n    - A number of precondition nodes as the first child nodes of the sequence node to check the action's preconditions.\n    - One action node as the last child of the sequence node, whose preconditions are checked in the child condition nodes before.\n    - The action should have effects that can fulfill the target condition node in the selector.\nFollowing is an example:\naction: change_tool(left_hand, outwardgripper)\nunit subtree:\n{\n    \"summary\": \"Selector to change the tool in the left hand from outwardgripper to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, outwardgripper, defaultgripper)\"\n    \"children\": [\n        {\n            \"summary\": \"The target is to make the left hand hold the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from outwardgripper to defaultgripper\", \n            \"name\": \"sequence: change_tool(left_hand, outwardgripper, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the outwardgripper\",\n                    \"name\": \"precondition: hold(left_hand, outwardgripper)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the outwardgripper is empty\",\n                    \"name\": \"precondition: is_empty(outwardgripper)\"\n                },\n                {\n                    \"summary\": \"Take the action to change the tool in the left hand from outwardgripper to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, outwardgripper, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}\n\n\n\n    Start working. Resume from the input below.\n---------------\naction: change_tool(left_hand, parallel_box1, defaultgripper)\n---------------\n\n\n    Return a JSON object.\n    "}, {"role": "assistant", "content": "{\n    \"summary\": \"Selector to change the tool in the left hand from parallel_box1 to defaultgripper\",\n    \"name\": \"selector: change_tool(left_hand, parallel_box1, defaultgripper)\",\n    \"children\": [\n        {\n            \"summary\": \"The target is to make the left hand hold the default gripper\",\n            \"name\": \"target: hold(left_hand, defaultgripper)\"\n        },\n        {\n            \"summary\": \"Sequence to change the tool in the left hand from parallel_box1 to defaultgripper\",\n            \"name\": \"sequence: change_tool(left_hand, parallel_box1, defaultgripper)\",\n            \"children\": [\n                {\n                    \"summary\": \"A precondition is that the left hand is holding the parallel_box1\",\n                    \"name\": \"precondition: hold(left_hand, parallel_box1)\"\n                },\n                {\n                    \"summary\": \"A precondition is that the parallel_box1 is empty\",\n                    \"name\": \"precondition: is_empty(parallel_box1)\"\n                },\n                {\n                    \"summary\": \"Take the action to change the tool in the left hand from parallel_box1 to defaultgripper\",\n                    \"name\": \"action: change_tool(left_hand, parallel_box1, defaultgripper)\"\n                }\n            ]\n        }\n    ]\n}"}]}
